#include "ZMQPubSubServer.h"

ZMQPubSubServer::ZMQPubSubServer() : context(1), publisher(NULL)
{
	
}

ZMQPubSubServer::~ZMQPubSubServer()
{
	if(publisher != NULL) {
		publisher->close();
		delete publisher;
	}
}

void ZMQPubSubServer::sendMessage(const String& msg)
{
	Thread().Run(THISBACK1(publisherLoop, msg));
}

void ZMQPubSubServer::publisherLoop(const String msg)
{
	/*
		1.	Can't create publisher socket at the beginning and delete it at the end here;
			As far as I could guess, after testing this prog in my home network setup,
			feels like calls made in tandem to this thread end up somehow jamming
			the context, so there may be no available time enough to delete a socket
			before creating the next one; this could explain the crashes I've had when
			running the prog in msg automode, regardless of the fact that each call
			to sendMessage spawns a fresh thread here, which in theory should create
			a fresh new socket, independent of the previous one;
		2.	This approach seems to be working fine, so far, at least:
			a) 	create a single new publisher socket in the stack to be used by all
				threads generated by all sendMessage calls;
			b)	delete socket obj if some error occurs when connecting to it;
				a fatal error certainly occurs when the machine where this routine is
				running is not connected to the network where the broker resides;
				(error = invalid argument).
			c) 	delete socket in class destructor when done; this avoids zombies.
	*/
	if(publisher == NULL) {
		try {
			publisher = new zmq::socket_t(context, ZMQ_PUB);
			publisher->connect("tcp://NOTEHOPE:5559");
		    //  Configure socket to not wait at close time
		    int linger = 0;
		    publisher->setsockopt (ZMQ_LINGER, &linger, sizeof (linger));
		} catch (zmq::error_t ex) {
			publisher->close();
			delete publisher;
			publisher = NULL;
			PostCallback(THISBACK1(processServerException, Format("%d - %s", errno, ex.what())));
			return;
		}
	}
	
	try
	{
	    //  Send message to broker
	    zmq::message_t message(msg.Begin(), msg.GetCount());
	    publisher->send(message);
	}
	catch (zmq::error_t ex)
	{
		PostCallback(THISBACK1(processServerException, Format("%d - %s", errno, ex.what())));
	}
}

void ZMQPubSubServer::processServerException(const String exc)
{
	DUMP(exc);
}








